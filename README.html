<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>README.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<h1 id="mission-dmm-bootcamp-go">mission-dmm-bootcamp-go</h1>

<p>TechBowl社MISSION用Templateリポジトリ(新卒研修-Go)</p>

<h2 id="tableofcontents">Table of Contents</h2>

<ul>
<li><a href="#mission">Mission</a></li>
<li><a href="#vocabulary">Vocabulary</a></li>
<li><a href="#development-environment">Development Environment</a>

<ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#start">Start</a></li>
<li><a href="#shutdown">Shutdown</a></li>
<li><a href="#log">Log</a></li>
<li><a href="#hot-reload">Hot Reload</a></li>
<li><a href="#swagger-ui">Swagger UI</a></li>
<li><a href="#db">DB</a></li>
</ul></li>
<li><a href="#code">Code</a>

<ul>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#library">Library</a></li>
<li><a href="#utilities">Utilities</a></li>
</ul></li>
</ul>

<h2 id="mission">Mission</h2>

<p>このMISSIONではDMMのGo新卒研修の演習課題を体験していただきます。</p>

<p>演習課題ではTwitter・Mastodonライクな仮想のサービス、Yatterを実装していきます。</p>

<p>みなさんにはこのMISSIONでYatterのバックエンドAPIを実装していただきます。</p>

<h2 id="vocabulary">Vocabulary</h2>

<ul>
<li>status：SNSへの投稿

<ul>
<li>follow：他のアカウントのステータスを購読すること</li>
<li>following：あるアカウントがfollowしているアカウント</li>
<li>follower：あるアカウントをfollowしているアカウント</li>
</ul></li>
<li>timeline：時系列順に並んだstatusの集まり

<ul>
<li>public timeline：全アカウントのstatusが集まるtimeline</li>
<li>home timeline：followしているアカウントのstatusが集まるtimeline</li>
</ul></li>
</ul>

<h2 id="developmentenvironment">Development Environment</h2>

<p>開発環境をdocker-composeで構築しています。</p>

<h3 id="requirements">Requirements</h3>

<ul>
<li>docker / docker-compose</li>
</ul>

<h3 id="start">Start</h3>

<pre><code>docker-compose up -d
</code></pre>

<h3 id="shutdown">Shutdown</h3>

<pre><code>docker-compose down
</code></pre>

<h3 id="log">Log</h3>

<pre><code># ログの確認
docker-compose logs

# ストリーミング
docker-compose logs -f

# webサーバonly
docker-compose logs web
docker-compose logs -f web
</code></pre>

<h3 id="hotreload">Hot Reload</h3>

<p><a href="https://github.com/cosmtrek/air">air</a>によるホットリロードをサポートしており、コードを編集・保存すると自動で反映されます。
読み込まれない場合は<code>docker-compose restart</code>を実行してください。</p>

<h3 id="swaggerui">Swagger UI</h3>

<p>API仕様をSwagger UIで確認できます。</p>

<p>開発環境を立ち上げ、Webブラウザで<a href="http://localhost:8081">localhost:8081</a>にアクセスしてください。</p>

<h4 id="test">Test</h4>

<p>各API定義の&quot;Try it out&quot;からAPIの動作確認を行うことができます。</p>

<h4 id="authentication">Authentication</h4>

<p>鍵マークのついたエンドポイントは認証付きエンドポイントです。</p>

<p><code>Authentication</code>というHTTPヘッダに<code>username ${ユーザー名}</code>を指定する単純な仕様です。</p>

<p>動作確認の際には画面上部の&quot;Authorize&quot;からヘッダの値の設定を行ってください。</p>

<h3 id="db">DB</h3>

<p>マイグレーションツールの用意はありません。</p>

<p>初回起動時に<code>ddl/</code>以下にあるSQLファイルが実行されます。
再読み込みの際は<code>.data/mysql/</code>を削除し、DBを初期化してください。</p>

<pre><code>docker-compose down  # 開発環境が稼働中なら止める
rm -rfd .data/mysql  # `.data/mysql/`以下を削除
docker-compose up -d # 再起動
</code></pre>

<h2 id="code">Code</h2>

<h3 id="architecture">Architecture</h3>

<pre><code>.
├── app      ----&gt; application core codes
│   ├── app      ----&gt; collection of dependency injected
│   ├── config   ----&gt; config
│   ├── domain   ----&gt; domain layer, core business logics
│   ├── handler  ----&gt; (interface layer &amp; application layer), request handlers
│   └── dao      ----&gt; (infrastructure layer), implementation of domain/repository
│
└── ddl      ----&gt; DB definition master
</code></pre>

<figure>
<img src="doc/module_dependency.png" alt="モジュールの依存関係" />
<figcaption>モジュールの依存関係</figcaption>
</figure>

<h4 id="app">app</h4>

<p>モジュールの依存関係を整理するパッケージで、DIコンテナを扱います。
今回は簡素なものになっていて、DAOの組み立てとhandlerのDAO（が提供するdomain/repository）への依存の管理のみ行っています。</p>

<h4 id="config">config</h4>

<p>サーバーの設定をまとめたパッケージです。DBやlistenするポートなどの設定を取得するAPIがまとめてあります。</p>

<h4 id="domain">domain</h4>

<p>アプリケーションのモデルを扱うdomain層のパッケージです。</p>

<h5 id="domainobject">domain/object</h5>

<p>ドメインに登場するデータ・モノの表現やその振る舞いを記述するパッケージです。
今回は簡単のためDTOの役割も兼ねています。</p>

<h5 id="domainrepository">domain/repository</h5>

<p>domain/objectで扱うEntityの永続化に関する処理を抽象化し、インターフェースとして定義するパッケージです。
具体的な実装はdaoパッケージで行います。</p>

<h4 id="handler">handler</h4>

<p>HTTPリクエストのハンドラを実装するパッケージです。
リクエストからパラメータを読み取り、エンドポイントに応じた処理を行ってレスポンスを返します。
機能の提供のために必要になる各種処理の実装は別のパッケージに切り分け、handlerは入出力に注力するケースも多いですが、今回は簡単のため統合しています。</p>

<h4 id="dao">dao</h4>

<p>domain/repositoryに対する実装を提供するパッケージです。
DBなど外部モジュールへアクセスし、データを永続化する処理を実装します。</p>

<h3 id="library">Library</h3>

<ul>
<li>HTTP

<ul>
<li>chi（<a href="https://pkg.go.dev/github.com/go-chi/chi">ドキュメント</a>）</li>
</ul></li>
<li>DB

<ul>
<li>sqlx（<a href="https://pkg.go.dev/github.com/jmoiron/sqlx">ドキュメント</a>）</li>
</ul></li>
</ul>

<h3 id="utilities">Utilities</h3>

<p>このテンプレートでは実装をサポートするユーティリティ関数を提供しています。</p>

<h4 id="apphandlerrequest">app/handler/request</h4>

<p>リクエストの扱いに関するユーティリティをまとめています。
テンプレートにはパスパラメータ<code>id</code>の読み取りを補助する関数<code>IDOf</code>を用意しています。</p>

<pre><code>// var r *http.Mux
r.Get(&quot;/{id}&quot;, func(w http.ResponseWriter, r *http.Request){
  id, err := request.IDOf(r)
  ...
})
</code></pre>

<h4 id="apphandlerhttperror">app/handler/httperror</h4>

<p>エラーレスポンスを返すためのユーティリティをまとめています。</p>

<pre><code>func SomeHandler(w http.ResponseWriter, r *http.Request) {
  ...
  if err != nil {
    httperror.InternalServerError(w, err)
	return
  }
  ...
}
</code></pre>

<h4 id="apphandlerauth">app/handler/auth</h4>

<p>認証付きエンドポイントの実装のためのミドルウェア関数を提供しています。
<code>chi.Mux#Use</code>や<code>chi.Mux#With</code>を用いて利用できます。</p>

<ul>
<li><a href="https://pkg.go.dev/github.com/go-chi/chi@v1.5.4">chiドキュメント</a></li>
</ul>

<p>ミドルウェアを埋め込んだエンドポイントでは<code>*http.Request</code>から<code>AccountOf</code>でリクエストと紐づくアカウントを取得できます。</p>

<pre><code>// var r *http.Request
account := auth.AccountOf(r)
</code></pre>

</body>
</html>
